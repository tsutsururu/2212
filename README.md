# 2212

# 1203

# ABLA   Repeat ACL   diff 10

解答遷移 AC

計 01:17

備考　

なし

# ABLB  Integer Preference  diff 51

解答遷移 AC

計 03:52

備考

➀　思考

A C の大小関係に注目し、A<C なら CとB ,  C<A　なら AとD の大小関係で条件判定した。

➁　解法

max(left) と min(right) で区間の被りを判定できる


# ABL C   Connect Cities  diff 435

解答遷移 AC

計 05:59

備考

➀　思考

連結成分を1頂点とみなしたグラフを作成すればよいので、連結成分-1 が答えになる


# 082C  Good Sequence  diff 593

解答遷移 AC

計 04:38

備考

➀　思考

個数を管理。出てくる要素を全探索して、その要素の値 > その要素の数 なら要素の数だけインクリメント。　その要素の値 < その要素の数 なら その要素の数 - その要素の値　だけインクリメント



1209

# 244D  Swap Hats  diff 165

解答遷移 AC

計 12:59

備考

➀　思考

全並び替えが6通りしかないので、偶数回の操作で到達可能な並びを素直に調べて T を判定すればよいと考えた。

➁　補足

転倒数の偶奇に注目することで 並び替えの数が増えても対応できる。

・転倒数

自分より前にある要素で、自分より大きな値がいくつあるかの総数

転倒数が偶数である並び替えを偶置換、奇数である並び替えを奇置換と呼ぶ

https://mathlandscape.com/permutation/


偶置換か、奇置換であるかは BIT で判定できる。



# BIT (Binary Index Tree) 勉強

値の更新と、自分より前の総和を O(logN)　で求められるデータ構造

http://hos.ac/slides/20140319_bit.pdf


https://ikatakos.com/pot/programming_algorithm/data_structure/binary_indexed_tree

x & (-x) が x(2) における一番下位の1の位置であることを利用して、x , x+( x&-x) , .... の値を更新する。ここで特定の値も更新しておくことで、総和演算が効率的に行えるようになる。

![image](https://user-images.githubusercontent.com/109026838/206773492-b7f977aa-774e-4e97-8292-280227e2b1f6.png)

具体的には、x , x-(x&-x) , ... を調べることで、自分より前の総和を計算可能になる。

![image](https://user-images.githubusercontent.com/109026838/206774186-d071a874-5c08-459a-9b01-5fd5b6267220.png)


注意点としては、bit演算の都合、与える要素は非負整数でなければいけないことである。

操作イメージ

https://scrapbox.io/pocala-kyopro/%E8%BB%A2%E5%80%92%E6%95%B0




# 1212 

# 145D Knight   diff 1009  2回目

解答遷移 AC

計32 :41

備考

➀　思考

負の方向には進まないので、コマの進め方を全部考えて何通りか導こうとした。→ 遷移を調べると、どうやらコマは合計が 3 の倍数になるマスにとまり、目的のマスの行き方は (1,2) 方向に何回進んだかで表現できそうだとわかった。ここで、(1,2) 方向に r1 回　(2,1) 方向に r2 回進むとすると、 r1 = (2Y-X)/3 , r2 = (2X-Y)/3 で表せる。したがって、これが非負整数の場合に、 (r1+r2) C r1 が求める解となると判断した。
また、 nCr = n!/(n-r)!/r! にしたがって、逆元を用いてこれらをそれぞれ求めればよいと考えた。


# nCr ライブラリ

nCr を O(1) で求めるためのライブラリを作成した。
x!(MOD) と 1/y!(MOD) の値を 1 から順に DPで求めた table を作成し、そこから塁積和の要領で必要な値をとりだして計算を行うことで nCr が求まるというものである。

COMinit が table 計算でこれは初めに一度行うだけでよい。必要になったら、COM を呼ぶことで値を求められる。

参考 
https://algo-logic.info/combination/

https://drken1215.hatenablog.com/entry/2018/06/08/210000

また、ユーグリッドの互除法でテーブルを計算する処理の方が圧倒的に高速である。フェルマーの小定理で求める遅い方を nCr_2.py に、ユーグリッドの互除法で求める速い方を nC1.py に保存しておいた。
現時点 (221212) では y の計算方法を理解していないが、フェルマーをわかっているので問題なしと考えている。

# 1217

# 057C Digits in Multiplication   diff 904

解答遷移 AC

計 08:41

備考

➀　思考

条件をみたす約数を約数列挙で求めればよいと判断。O(√N) より十分高速。　→ k1* k2= N, s1* s2= N ,k1<s1 となる約数のペアについて、桁数は k1 ≦ s1 ≦ s2 ≦ k2　を満たす。つまり、条件を満たすペアは ( s1 ,s2 )となる。よって最も√N に近い約数を持つペアの大きい方を求めてその桁数を出力した

# joi 2009 予選 D  薄氷割り

解答遷移 AC

備考

➀　思考

dfsで経路をFalse にしながら探索し、帰りがけで連続区間の個数を求める方針を考えた。連結区間の大きさではないので、始点を変えて探索しなおす必要がある。

今何個目かを表す tmp変数を持っておき、再帰関数が呼ばれるたびに ans 変数へ代入。帰りがけで ans をtmp変数と比較して更新し、返り値とすることでその始点からの経路における最大値を求められるようにできると考えた。

➁　再帰関数参考

https://qiita.com/ryo2132/items/4bedeec846d0427f1ac7


# 265D Iroha and Haiku (New ABC Edition)   diff 727

解答遷移 AC

計 39:00

備考

➀　思考

Ax + ... Aw-1 = P+Q+R であるが、和にしてしまうと各区間の情報が消えるので、それぞれ別々で求める必要があると考えた。→ Ax-1 を探索して P,Q,R に A1～Ax-1 までを追加して累積和を二分探索すれば O(NlogN) で十分高速ではあるが、二分探索を繰りかえす気持ち悪さのため、前から探索しながらスマートに解答する代案を探したが見つからなかったので提出　→ AC


➁　別解

各区間を尺取り法で探索する。Ax-1 を更新することで、Ay-1,Az-1,Aw-1 がすべて一気に更新する模範解答らしい気持ちよさがある。

このように、部分的な区間の探索には二分探索より尺取り法が優れる。二分探索は全体の探索アルゴリズムとしては最強だが、異なる区間を探索するためには始点を動かして二分探索をやり直す必要が生じて尺取り法に劣る。(それでも十分高速なので解けはする)



# 1221

# 098D Xor Sum 2  diff 1404

解答遷移  AC

計 49:25

備考

➀　思考

始点をずらした区間の探索なので尺取り法　→ Sk-1 ^ Ak = Sk ⇔ Sk-1 = Sk ^ Ak を利用して 和と排他的論理和の累積和を求めておき、O(1) で区間の和と排他的論理和を求められるようにした。

(left,right] になっている点、right ポインタを進めるための条件で範囲外参照しないようにする点、に注意



# 196E ☆ Hanjo   diff 1277

備考

➀　思考

dfs で置き方を全探索しようとしたが、帰りがけに行ったことを忘れると同じ置き方を重複して数えることになってしまった

➁ 解法

dfs で置き方を全探索するが、置いた頂点を進んでいくのではなく、マス目を(dp のように)左上から順番に探索し畳を置くか置かないか選択する方法でうまくいく。

③ bit dp

畳の置き方を bit で管理する。例えば 1010 なら2マス目と4マス目に畳があることを示す。

1マス目に畳を置く場合、例えば 0000 の置き方 を 0011,0101 の置き方に加えればよい。つまり、1, 何マス目か 2,置き方 3,置き方の数 の情報で全ての遷移を把握できる。計算量は O(N* 2^N : マス目 × 置き方の種類) となり十分高速

マスからはみ出す置き方を除くこと、横に置く場合はそのマスに既に置かれていない場合に限ること、置かない場合を正しく更新することに注意する

また、実装では 1桁目からマスの状態を表して 0桁目は初期状態の管理に利用している。そのため dp の1行目から2行目への遷移は、初期状態から 1マス目への状態の更新を表していて、1桁のズレを調整する必要があることに気をつける

④ 追記

HW<=200 の場合は、約数の小さい方が 10以下であることを利用し、「 幅を活用した動的計画法 」で解く、、、らしいがよくわからなかったので一旦パス

参考

https://trap.jp/post/463/

④ 追記2  0129

01-BFS　でグラフを構築するイメージ意識を理解した後でこの問題も同じように考えられるのではないかと、突然降ってきた。

図のように、あるマスと次のマスとの辺を構築していく dfs を行う。このとき、畳を置く先の頂点と辺を結ぶわけではないことに注意

![image](https://user-images.githubusercontent.com/109026838/215714655-b782e632-621f-4666-83a8-3748519da50f.png)



# 242D Transform     diff 1286

解答遷移 AC

計 1:21:41

備考

➀　思考

木を考えると、根を求めることでこの問題を解けそうだと考えた。しかし、最高で t 回さかのぼる必要があり、これを素直に実装することは不可能。→ k=0 or t=0 になるまで繰り返して求めた根' と 根 には 根 ' = 根 + t の関係が成立することに気が付き、根' まで求めれれればこの問題を解答できると判断　→ 根' までは最高でも 60回で到達できるので計算量は全体で O(60* N)となって十分高速

時間が死ぬほどかかったのは、思考が固まっているようで固まっていない中、求める位置を根と勘違いしたりしたため



# 1222

# ☆ 262 I Hate Non-integer Number   diff 1213

降参

備考

➀　思考

各要素を余りで分類すれば 和がある倍数になる組み合わせを求められそうだが、条件を設定するのは難しいので、全探索したい　→ Aiを含めた A1 ～ Ai までの n個の和が kの倍数になるための条件は、「 A1 ～ Ai-1 までの n-1 個の和の余り + Ai がk の倍数になる　」と考えて遷移を追えば解けそう。→ しかし遷移の中で個数が変化する度に、必要なあまりが変ってしまう点をうまく解消できず降参

➁　解法

注目する個数(倍数) を固定すれば、遷移の中で余りが変動しないので、これを 1 ～ N まで繰り返せばよい。

参考

u2dayo
https://magicode.io/u2dayo/articles/81c49bf40cf9431681e5d3399554a965

③ 反省

終わってみると　281D における倍数 D　が動くver でしかないので、「 動くと面倒な要素を固定して考える 」思考が自分に足りていないことが明確になった。

最初の簡単な実験においても、1～100 までで分けて A の要素をその余りで分類していたのだが、dpを考えているときにはそんな考えが消え失せていた。解くために必要なものはすべて揃っているのでおしいように感じるが、遠い。まだ武器になってない。


# ☆  257D Jumping Takahashi 2   diff 1203 

降参

備考

➀　思考

最大のジャンプ台をもつ頂点を始点としたときの 最小の辺をなす頂点を求め、その頂点を次の始点にこれを繰り返して全頂点を探索する処理によって、最大の辺を求めることができると考えた。

➁ 解法1

このような反例で、最大のジャンプ台がある頂点を始点にする方針は間違い

![image](https://user-images.githubusercontent.com/109026838/209312488-7723e07a-670d-4de1-bb1f-338b1bcd6518.png)

その頂点を始点とした場合の最大の辺を求めること自体はできているので、始点も全探索すれば O(N^3 : 始点　× 全頂点探索 N^2) で十分高速にこの問題を解くことが可能である。


③　解法 2

ワーシャルフロイド法によって全点間最短距離を求めておけば、始点を固定した場合の最大の距離を求めることが可能になる。したがって、始点を全探索してこれらの最小値を求めばよい

④　解法 3

ジャンプ力を二分探索し、mid 以下の辺を張ったグラフが有向全域木になっているか判定することでこの問題を解答できる

有向全域木になっているかどうかは、BFSで全頂点を探索できるか調べたり や　ワーシャルフロイト法で度の頂点にも辺が張られているか調べることで求められるので　計算量は O(N^3 log10^9) 

⑤　補足

https://atcoder.jp/contests/abc257/editorial/4281

この解法は手を付けていない。いつかやる


# グラフ理論　勉強

・全域木

全頂点が連結している木

・強連結成分

始点と終点が一致する連結成分

・DAG 

非巡回有向グラフ。閉路のない有向グラフを指す



# ワーシャルフロイド法 勉強

全点間最短距離を O (N^3) で求めるアルゴリズム。中継点を kとして (i,j) 間距離 dist[i][j] を dist[i][k] + dist[k][j] と比較して更新していく。

また、経路復元のために prev リストを作成して、dist が更新されるたびに、 prev[i][j]= prev[k][j] としていく。= k としない理由は以下。 prev リストの初期値は 行のindex 番号にすることで　ゴールから始点までの経路を求められる

![image](https://user-images.githubusercontent.com/109026838/209309721-1a96a94c-0cbf-4b8f-babc-ba37f0b5ad29.png)




# 1224

# アルゴ式 

# 8-6 グリッドグラフ(2)

解答遷移 AC

備考

➀　思考

最大の辺をなす 2頂点から順に union していき最大全域木を作成すればよいと考えた。辺を左上にある頂点、その辺が縦か横か、の情報で管理することで適切に連結することを可能にした。

➁　クラスカル法の正当性

https://algo-method.com/tasks/1011/editorial


# 250D 250-like Number  diff 797   2回目

備考

q の値は p の値が増加すると単調に減少する。この単調性注目すれば尺取り法で自然に解答可能。なお、q <= p になったら打ち止めること、  q が範囲外にならないようにすることに注意

# 254E Small d and k  diff 1202

解答遷移 TLE → AC

計 26:03

備考

➀　思考

次数 3 が最大のグラフにおいて　距離 3　までの頂点までしか調べなくて良いので クエリごとに BFS しても O(Q × (1+3+6+12) ) で余裕で間に合うと考えた。　→ TLE → 距離管理リストをクエリごとに初期化することで O(QN) になってしまっていることに気が付く。更新された頂点を覚えておき、最後にその頂点を初期化すれば、リスト全体を初期化するより軽く十分高速だと判断して AC


# 1225

# 172C Tsundoku   2回目   diff 930

解答遷移 AC

計 14:20

備考

➀　思考

dp っぽいが制約きつい(N,M < 2.0* 10^5 なので dpできるテーブル作れない) 。時間が小さいものから貪欲に選ぶのもできない　→ 読める本を二分探索で調べることを考えたが、何冊よめるか判断する方法がわからない　→  A , B が二つとも動くことが問題の難しさなので A を固定して考えてみる　→ すると B を何冊よめるかわかる上に、A が増加すると B が減少する単調性を発見　→ 尺取り法で AC

*補足

少しネタバレを食らっていたために綺麗に解答できた。初見で解ける自信 3割




# 218C shapes  diff  1012  2回目

解答遷移 AC

計 30 分未満

備考

➀　思考

平衡移動を行って O(200^2) で全マス探索すれば、その向きでの一致判定は可能。これを全ての向きで行えば全判定できるが、何度も平衡移動、回転を行うのは面倒なので、疑似的にこれを実現できないか考えた。
図のように始点と探索方法を設定すれば、疑似的な操作を実現できると判断して、一度に全ての向きでの判定を実行した。

![image](https://user-images.githubusercontent.com/109026838/209462385-77c3f0e1-73d5-4341-a159-ca21d6b1c6a3.png)

![image](https://user-images.githubusercontent.com/109026838/209462395-c73c3d4c-e036-4834-aa14-ad7c704dad78.png)



# 218 E  Destruction    2回目  diff 1044

解答遷移 AC

計 08:37

備考

➀　思考

最小全域木を作成し、使用しなかった正の辺の重みの総和を求めればよいと判断


# 254D  Together Square   diff 1191    2回目

解答遷移 AC

計 30:49

備考

➀　思考

(i,j) は指数が奇数になる素因数の積 X を用いて (aX,bX) と表せる。このとき、a,b はそれぞれ平方数であるので、X倍した平方数のうち N 以下であるもののが (i,j) の候補となる。またこのとき、条件を満たす (i,j) の個数は その平方数の個数の二乗である。
したがって、1 ≦ X ≦ N を満たす X を全探索して、二分探索で平方数の個数を求めることでこの問題を解けると判断。X倍した 平方数は再探索しない方が数え上げに都合が良いので、X × (1,4,9,...) に含まれたものを X として探索されないようにスキップすることにした。この時、1　～ N のすべてに対して ➀ 平方数二分探索 ➁ 探索済みチェック の処理が生じる可能性があるが、これは計算量 O( N logN ) であるので十分高速と判断して提出　→ AC

➁　別解

・1114 初見案

エラストテネスの篩による素因数分解によって、指数が奇数になる積の個数を求めていた。


・ 1 ～ N まで平方数で割れるだけ割ってグループ分け

考えは ➀ と同じ。処理が異なる。

エラストテネスの篩の要領で 1 ～ N　まで平方数で割れるだけ割ることでグループ分けができる。計算量は O(NlogN [篩] * log2 N [最小素因数 2 で割れる最高回数]) で十分高速

* 補足

線形篩のアルゴリズムを使うと O(√N)らしい。いつかやる

1226 

# 260D Draw Your Cards   diff 1074   2回目

解答遷移 AC

計 58:12

備考

➀　思考

必要な情報は、➀ 場にあるカードが何か　➁ 場にあるカードの下にあるカードの内容と枚数 である。また、➀ は その順番まで管理する必要があるので、SortedSet で管理し、各操作を O(√N) で行いたい。→ あとは「そのカードの下に含まれるカードの枚数と、それらのうち一番上にあるもの」を辞書で管理すれば食べるときに、連結リストの要領で O(1) で取り出せると考えた。したっがて計算量は O(N√N) となり十分高速　→ AC


補足

初見時の記録をさぼっていた上に、コードが死ぬほどめんどそうなので、これを初見考察とする！！


# 260C  Changing Jewels  2回目  diff 413

解答遷移 AC

計 13:54

備考

➀　思考

1,赤か青か 2,レベル 3, 個数 の３つの情報で全ての遷移を把握可能。したがって、サイズ (N* 2) のテーブルで状態を管理すればよいと判断。なお、操作は N-1 行目までで打ち止めることに注意。(レベル 2までしか操作しないため)

➁　別解

メモ化再帰でも解答可能。赤レベル１で return 0 青レベル 1　で return 1 とすれば 青レベル 1 の個数を求められる。

③　感想

dp 一瞬 メモ化 1時間　くらい差があった。再帰を検討することをさぼらないで練習する必要あり

・ポイント

始点と終点を逆にしたこと、青1、青1 で何を返すべきかすぐわからなかったこと。



# 217E Sorting Queries  diff 987   2回目

解答遷移 AC

計 17:36

備考

➀　思考

素直にソートすると O( Q^2 × logQ ) になるのでこれはできない。そこで、データを管理する場所を2つ作成し1つをヒープにする。これで各クエリを以下の操作で擬似的に実現できることになる。

1, ヒープでないほうの末尾に x を追加

2, ヒープの最小値を出力。ヒープが空なら、もう一つの先頭を出力

3, もう一つの要素を全てヒープに移す。

2 で先頭からの取り出しを行うため、もう一つのデータ構造は キューにする。ここで、クエリで登場した x に対して、キューに追加　→ キューから取り出しヒープに追加 → ヒープから取り出しを行う可能性があるが、これは最悪でも O(logQ) で行えるので、計算量は全体で (QlogQ) となり十分高速と判断




# ☆ 176D Wizard in Maze   diff 1248

降参

備考

➀　思考

そのマスへいくために最小で何回魔法を使う必要があるかを表すコスト配列を作成し、行先のマスのコスト > 現在のマスのコスト である場合だけコストを更新しながら進む dfs でこの問題を解けると考えた。しかし、あるマスを更新した場合それ以降の全てのマスを探索しなおす必要が生じる。最悪 (HW//25 * HW) となるのでこれでは間に合わない


➁　解法


隣接 4 マスへ重み 0 の辺が、それ以外の 20 マスへ重み 1 の辺が連結しているグラフであると解釈することでこの問題を解くことが可能。すなわち 01-BFS で各マスへ始点から移動できる最短回数を求めればよい。




③ dfs 

最短経路問題同様、値を最適化する経路を求めることを dfs は得意としない。



④ 別解

ダイクストラ法でも最短回数を求められるが、計算量 O( 25* HW log (25* HW) ) は TLE してしまう。

一応 maspy 曰く、numba で高速化できるらしいが、numba 理解が面倒だし過去困ったことが一度もないのでとりあえず後回わし。いつかやる


# 01-BFS 

重みをもつ辺からなるグラフにおいて、ある始点からの各頂点までの最短距離を求めるためのアルゴリズム。que の先頭から 0 辺を、後から 1 辺を格納することで適切な順序での探索が可能になる。計算量 O( E ) より後述する ダイクストラ法よりも効率的。

# ダイクストラ法

重みをもつ辺からなるグラフにおいて、ある始点からの各頂点までの最短距離を求めるためのアルゴリズム。01-BFS が 0,1 辺に限定するのに対して、ダイクストラ法は非負整数の範囲に対応する。具体的には見探索辺を 優先度付きキューで管理することで適切な順序での探索を行う。計算量はヒープを扱うぶん O( E log E )　となってしまう。

また、直前にいた頂点を一緒にヒープに加えることで経路を復元できるようになる。prev リストを作成し、prev[行先] = 直前の頂点 と更新していく。なお、ワーシャルフロイド法とは異なり、中継点が存在しないので 直前の頂点をそのまま格納すればよい。


# アルゴ式 グラフ

# 7-10 & 7-11

解答遷移 AC

備考

➀　思考

ダイクストラ法で各頂点までの最小距離を求める

# 129D  Lamp  diff 1103

解答遷移 AC

計 28:18

備考

➀　思考

始点を全探索して、dfs すれば答えは求められそうだが、最悪計算量が O((H+W) × HW ) となるで間に合わない。 → そのマスで何マス照らせるか 定数時間で求められないか考えたところ、行と列それぞれにおいて最も近い障害物の位置を二分探索すれば良さそうだと判断 → 障害物の位置リストを作成し、自分自身を重複して数えてしまう点を修正して AC

なお、二分探索しやすいようにあらかじめ 障害物で周囲を囲った

➁ 補足

この問題は python では TLE するらしいと聞いて、もしTLE するなら numba 高速化を学ぶ必要があるなと考えたが、pypy で余裕だったので、numba を後回しすることを決意


# 1230

# 282D Make Bipartite 2  diff 1154

https://qiita.com/Waaaa1471/items/fb2e1b0b3cd1a921054d

でまとめた

































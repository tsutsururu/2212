# 2212

# 1203

# ABLA   Repeat ACL   diff 10

解答遷移 AC

計 01:17

備考　

なし

# ABLB  Integer Preference  diff 51

解答遷移 AC

計 03:52

備考

➀　思考

A C の大小関係に注目し、A<C なら CとB ,  C<A　なら AとD の大小関係で条件判定した。

➁　解法

max(left) と min(right) で区間の被りを判定できる


# ABL C   Connect Cities  diff 435

解答遷移 AC

計 05:59

備考

➀　思考

連結成分を1頂点とみなしたグラフを作成すればよいので、連結成分-1 が答えになる


# 082C  Good Sequence  diff 593

解答遷移 AC

計 04:38

備考

➀　思考

個数を管理。出てくる要素を全探索して、その要素の値 > その要素の数 なら要素の数だけインクリメント。　その要素の値 < その要素の数 なら その要素の数 - その要素の値　だけインクリメント



1209

# 244D  Swap Hats  diff 165

解答遷移 AC

計 12:59

備考

➀　思考

全並び替えが6通りしかないので、偶数回の操作で到達可能な並びを素直に調べて T を判定すればよいと考えた。

➁　補足

転倒数の偶奇に注目することで 並び替えの数が増えても対応できる。

・転倒数

自分より前にある要素で、自分より大きな値がいくつあるかの総数

転倒数が偶数である並び替えを偶置換、奇数である並び替えを奇置換と呼ぶ

https://mathlandscape.com/permutation/


偶置換か、奇置換であるかは BIT で判定できる。



# BIT (Binary Index Tree) 勉強

値の更新と、自分より前の総和を O(logN)　で求められるデータ構造

http://hos.ac/slides/20140319_bit.pdf


https://ikatakos.com/pot/programming_algorithm/data_structure/binary_indexed_tree

x & (-x) が x(2) における一番下位の1の位置であることを利用して、x , x+( x&-x) , .... の値を更新する。ここで特定の値も更新しておくことで、総和演算が効率的に行えるようになる。

![image](https://user-images.githubusercontent.com/109026838/206773492-b7f977aa-774e-4e97-8292-280227e2b1f6.png)

具体的には、x , x-(x&-x) , ... を調べることで、自分より前の総和を計算可能になる。

![image](https://user-images.githubusercontent.com/109026838/206774186-d071a874-5c08-459a-9b01-5fd5b6267220.png)


注意点としては、bit演算の都合、与える要素は非負整数でなければいけないことである。

操作イメージ

https://scrapbox.io/pocala-kyopro/%E8%BB%A2%E5%80%92%E6%95%B0




# 1212 

# 145D Knight   diff 1009  2回目

解答遷移 AC

計32 :41

備考

➀　思考

負の方向には進まないので、コマの進め方を全部考えて何通りか導こうとした。→ 遷移を調べると、どうやらコマは合計が 3 の倍数になるマスにとまり、目的のマスの行き方は (1,2) 方向に何回進んだかで表現できそうだとわかった。ここで、(1,2) 方向に r1 回　(2,1) 方向に r2 回進むとすると、 r1 = (2Y-X)/3 , r2 = (2X-Y)/3 で表せる。したがって、これが非負整数の場合に、 (r1+r2) C r1 が求める解となると判断した。
また、 nCr = n!/(n-r)!/r! にしたがって、逆元を用いてこれらをそれぞれ求めればよいと考えた。


# nCr ライブラリ

nCr を O(1) で求めるためのライブラリを作成した。
x!(MOD) と 1/y!(MOD) の値を 1 から順に DPで求めた table を作成し、そこから塁積和の要領で必要な値をとりだして計算を行うことで nCr が求まるというものである。

COMinit が table 計算でこれは初めに一度行うだけでよい。必要になったら、COM を呼ぶことで値を求められる。

参考 
https://algo-logic.info/combination/

https://drken1215.hatenablog.com/entry/2018/06/08/210000

また、ユーグリッドの互除法でテーブルを計算する処理の方が圧倒的に高速である。フェルマーの小定理で求める遅い方を nCr_2.py に、ユーグリッドの互除法で求める速い方を nC1.py に保存しておいた。
現時点 (221212) では y の計算方法を理解していないが、フェルマーをわかっているので問題なしと考えている。

# 1217

# 057C Digits in Multiplication   diff 904

解答遷移 AC

計 08:41

備考

➀　思考

条件をみたす約数を約数列挙で求めればよいと判断。O(√N) より十分高速。　→ k1* k2= N, s1* s2= N ,k1<s1 となる約数のペアについて、桁数は k1 ≦ s1 ≦ s2 ≦ k2　を満たす。つまり、条件を満たすペアは ( s1 ,s2 )となる。よって最も√N に近い約数を持つペアの大きい方を求めてその桁数を出力した

# joi 2009 予選 D  薄氷割り

解答遷移 AC

備考

➀　思考

dfsで経路をFalse にしながら探索し、帰りがけで連続区間の個数を求める方針を考えた。連結区間の大きさではないので、始点を変えて探索しなおす必要がある。

今何個目かを表す tmp変数を持っておき、再帰関数が呼ばれるたびに ans 変数へ代入。帰りがけで ans をtmp変数と比較して更新し、返り値とすることでその始点からの経路における最大値を求められるようにできると考えた。

➁　再帰関数参考

https://qiita.com/ryo2132/items/4bedeec846d0427f1ac7


# 265D Iroha and Haiku (New ABC Edition)   diff 727

解答遷移 AC

計 39:00

備考

➀　思考

Ax + ... Aw-1 = P+Q+R であるが、和にしてしまうと各区間の情報が消えるので、それぞれ別々で求める必要があると考えた。→ Ax-1 を探索して P,Q,R に A1～Ax-1 までを追加して累積和を二分探索すれば O(NlogN) で十分高速ではあるが、二分探索を繰りかえす気持ち悪さのため、前から探索しながらスマートに解答する代案を探したが見つからなかったので提出　→ AC


➁　別解

各区間を尺取り法で探索する。Ax-1 を更新することで、Ay-1,Az-1,Aw-1 がすべて一気に更新する模範解答らしい気持ちよさがある。

このように、部分的な区間の探索には二分探索より尺取り法が優れる。二分探索は全体の探索アルゴリズムとしては最強だが、異なる区間を探索するためには始点を動かして二分探索をやり直す必要が生じて尺取り法に劣る。(それでも十分高速なので解けはする)




# ☆ Hanjo   diff 1277

備考

➀　思考

dfs で置き方を全探索しようとしたが、帰りがけに行ったことを忘れると同じ置き方を重複して数えることになってしまった

➁ 解法

dfs で置き方を全探索するが、置いた頂点を進んでいくのではなく、マス目を(dp のように)左上から順番に探索し畳を置くか置かないか選択する方法でうまくいく。

③ bit dp

畳の置き方を bit で管理する。例えば 1010 なら2マス目と4マス目に畳があることを示す。

1マス目に畳を置く場合、例えば 0000 の置き方 を 0011,0101 の置き方に加えればよい。つまり、1, 何マス目か 2,置き方 3,置き方の数 の情報で全ての遷移を把握できる。計算量は O(N* 2^N : マス目 × 置き方の種類) となり十分高速

マスからはみ出す置き方を除くこと、横に置く場合はそのマスに既に置かれていない場合に限ること、置かない場合を正しく更新することに注意する

また、実装では 1桁目からマスの状態を表して 0桁目は初期状態の管理に利用している。そのため dp の1行目から2行目への遷移は、初期状態から 1マス目への状態の更新を表していて、1桁のズレを調整する必要があることに気をつける

④ 追記

HW<=200 の場合は、約数の小さい方が 10以下であることを利用し、「 幅を活用した動的計画法 」で解く、、、らしいがよくわからなかったので一旦パス

参考

https://trap.jp/post/463/















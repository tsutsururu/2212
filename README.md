# 2212

# 1203

# ABLA   Repeat ACL   diff 10

解答遷移 AC

計 01:17

備考　

なし

# ABLB  Integer Preference  diff 51

解答遷移 AC

計 03:52

備考

➀　思考

A C の大小関係に注目し、A<C なら CとB ,  C<A　なら AとD の大小関係で条件判定した。

➁　解法

max(left) と min(right) で区間の被りを判定できる


# ABL C   Connect Cities  diff 435

解答遷移 AC

計 05:59

備考

➀　思考

連結成分を1頂点とみなしたグラフを作成すればよいので、連結成分-1 が答えになる


# 082C  Good Sequence  diff 593

解答遷移 AC

計 04:38

備考

➀　思考

個数を管理。出てくる要素を全探索して、その要素の値 > その要素の数 なら要素の数だけインクリメント。　その要素の値 < その要素の数 なら その要素の数 - その要素の値　だけインクリメント



1209

# 244D  Swap Hats  diff 165

解答遷移 AC

計 12:59

備考

➀　思考

全並び替えが6通りしかないので、偶数回の操作で到達可能な並びを素直に調べて T を判定すればよいと考えた。

➁　補足

転倒数の偶奇に注目することで 並び替えの数が増えても対応できる。

・転倒数

自分より前にある要素で、自分より大きな値がいくつあるかの総数

転倒数が偶数である並び替えを偶置換、奇数である並び替えを奇置換と呼ぶ

https://mathlandscape.com/permutation/


偶置換か、奇置換であるかは BIT で判定できる。



# BIT (Binary Index Tree) 勉強

値の更新と、自分より前の総和を O(logN)　で求められるデータ構造

http://hos.ac/slides/20140319_bit.pdf


https://ikatakos.com/pot/programming_algorithm/data_structure/binary_indexed_tree

x & (-x) が x(2) における一番下位の1の位置であることを利用して、x , x+( x&-x) , .... の値を更新する。ここで特定の値も更新しておくことで、総和演算が効率的に行えるようになる。

![image](https://user-images.githubusercontent.com/109026838/206773492-b7f977aa-774e-4e97-8292-280227e2b1f6.png)

具体的には、x , x-(x&-x) , ... を調べることで、自分より前の総和を計算可能になる。

![image](https://user-images.githubusercontent.com/109026838/206774186-d071a874-5c08-459a-9b01-5fd5b6267220.png)


注意点としては、bit演算の都合、与える要素は非負整数でなければいけないことである。

操作イメージ

https://scrapbox.io/pocala-kyopro/%E8%BB%A2%E5%80%92%E6%95%B0




# 1212 

# 145D Knight   diff 1009  2回目

解答遷移 AC

計32 :41

備考

➀　思考

負の方向には進まないので、コマの進め方を全部考えて何通りか導こうとした。→ 遷移を調べると、どうやらコマは合計が 3 の倍数になるマスにとまり、目的のマスの行き方は (1,2) 方向に何回進んだかで表現できそうだとわかった。ここで、(1,2) 方向に r1 回　(2,1) 方向に r2 回進むとすると、 r1 = (2Y-X)/3 , r2 = (2X-Y)/3 で表せる。したがって、これが非負整数の場合に、 (r1+r2) C r1 が求める解となると判断した。
また、 nCr = n!/(n-r)!/r! にしたがって、逆元を用いてこれらをそれぞれ求めればよいと考えた。


# nCr ライブラリ

nCr を O(1) で求めるためのライブラリを作成した。
x!(MOD) と 1/y!(MOD) の値を 1 から順に DPで求めた table を作成し、そこから塁積和の要領で必要な値をとりだして計算を行うことで nCr が求まるというものである。

COMinit が table 計算でこれは初めに一度行うだけでよい。必要になったら、COM を呼ぶことで値を求められる。

参考 
https://algo-logic.info/combination/

https://drken1215.hatenablog.com/entry/2018/06/08/210000

また、ユーグリッドの互除法でテーブルを計算する処理の方が圧倒的に高速である。フェルマーの小定理で求める遅い方を nCr_2.py に、ユーグリッドの互除法で求める速い方を nC1.py に保存しておいた。
現時点 (221212) では y の計算方法を理解していないが、フェルマーをわかっているので問題なしと考えている。

# 1217

# 057C Digits in Multiplication   diff 904

解答遷移 AC

計 08:41

備考

➀　思考

条件をみたす約数を約数列挙で求めればよいと判断。O(√N) より十分高速。　→ k1* k2= N, s1* s2= N ,k1<s1 となる約数のペアについて、桁数は k1 ≦ s1 ≦ s2 ≦ k2　を満たす。つまり、条件を満たすペアは ( s1 ,s2 )となる。よって最も√N に近い約数を持つペアの大きい方を求めてその桁数を出力した

# joi 2009 予選 D  薄氷割り

解答遷移 AC

備考

➀　思考

dfsで経路をFalse にしながら探索し、帰りがけで連続区間の個数を求める方針を考えた。連結区間の大きさではないので、始点を変えて探索しなおす必要がある。

今何個目かを表す tmp変数を持っておき、再帰関数が呼ばれるたびに ans 変数へ代入。帰りがけで ans をtmp変数と比較して更新し、返り値とすることでその始点からの経路における最大値を求められるようにできると考えた。

➁　再帰関数参考

https://qiita.com/ryo2132/items/4bedeec846d0427f1ac7


# 265D Iroha and Haiku (New ABC Edition)   diff 727

解答遷移 AC

計 39:00

備考

➀　思考

Ax + ... Aw-1 = P+Q+R であるが、和にしてしまうと各区間の情報が消えるので、それぞれ別々で求める必要があると考えた。→ Ax-1 を探索して P,Q,R に A1～Ax-1 までを追加して累積和を二分探索すれば O(NlogN) で十分高速ではあるが、二分探索を繰りかえす気持ち悪さのため、前から探索しながらスマートに解答する代案を探したが見つからなかったので提出　→ AC


➁　別解

各区間を尺取り法で探索する。Ax-1 を更新することで、Ay-1,Az-1,Aw-1 がすべて一気に更新する模範解答らしい気持ちよさがある。

このように、部分的な区間の探索には二分探索より尺取り法が優れる。二分探索は全体の探索アルゴリズムとしては最強だが、異なる区間を探索するためには始点を動かして二分探索をやり直す必要が生じて尺取り法に劣る。(それでも十分高速なので解けはする)



# 1221

# 098D Xor Sum 2  diff 1404

解答遷移  AC

計 49:25

備考

➀　思考

始点をずらした区間の探索なので尺取り法　→ Sk-1 ^ Ak = Sk ⇔ Sk-1 = Sk ^ Ak を利用して 和と排他的論理和の累積和を求めておき、O(1) で区間の和と排他的論理和を求められるようにした。

(left,right] になっている点、right ポインタを進めるための条件で範囲外参照しないようにする点、に注意



# ☆ Hanjo   diff 1277

備考

➀　思考

dfs で置き方を全探索しようとしたが、帰りがけに行ったことを忘れると同じ置き方を重複して数えることになってしまった

➁ 解法

dfs で置き方を全探索するが、置いた頂点を進んでいくのではなく、マス目を(dp のように)左上から順番に探索し畳を置くか置かないか選択する方法でうまくいく。

③ bit dp

畳の置き方を bit で管理する。例えば 1010 なら2マス目と4マス目に畳があることを示す。

1マス目に畳を置く場合、例えば 0000 の置き方 を 0011,0101 の置き方に加えればよい。つまり、1, 何マス目か 2,置き方 3,置き方の数 の情報で全ての遷移を把握できる。計算量は O(N* 2^N : マス目 × 置き方の種類) となり十分高速

マスからはみ出す置き方を除くこと、横に置く場合はそのマスに既に置かれていない場合に限ること、置かない場合を正しく更新することに注意する

また、実装では 1桁目からマスの状態を表して 0桁目は初期状態の管理に利用している。そのため dp の1行目から2行目への遷移は、初期状態から 1マス目への状態の更新を表していて、1桁のズレを調整する必要があることに気をつける

④ 追記

HW<=200 の場合は、約数の小さい方が 10以下であることを利用し、「 幅を活用した動的計画法 」で解く、、、らしいがよくわからなかったので一旦パス

参考

https://trap.jp/post/463/



# 242D Transform     diff 1286

解答遷移 AC

計 1:21:41

備考

➀　思考

木を考えると、根を求めることでこの問題を解けそうだと考えた。しかし、最高で t 回さかのぼる必要があり、これを素直に実装することは不可能。→ k=0 or t=0 になるまで繰り返して求めた根' と 根 には 根 ' = 根 + t の関係が成立することに気が付き、根' まで求めれれればこの問題を解答できると判断　→ 根' までは最高でも 60回で到達できるので計算量は全体で O(60* N)となって十分高速

時間が死ぬほどかかったのは、思考が固まっているようで固まっていない中、求める位置を根と勘違いしたりしたため



# 1222

# ☆ 262 I Hate Non-integer Number   diff 1213

降参

備考

➀　思考

各要素を余りで分類すれば 和がある倍数になる組み合わせを求められそうだが、条件を設定するのは難しいので、全探索したい　→ Aiを含めた A1 ～ Ai までの n個の和が kの倍数になるための条件は、「 A1 ～ Ai-1 までの n-1 個の和の余り + Ai がk の倍数になる　」と考えて遷移を追えば解けそう。→ しかし遷移の中で個数が変化する度に、必要なあまりが変ってしまう点をうまく解消できず降参

➁　解法

注目する個数(倍数) を固定すれば、遷移の中で余りが変動しないので、これを 1 ～ N まで繰り返せばよい。

参考

u2dayo
https://magicode.io/u2dayo/articles/81c49bf40cf9431681e5d3399554a965

③ 反省

終わってみると　281D における倍数 D　が動くver でしかないので、「 動くと面倒な要素を固定して考える 」思考が自分に足りていないことが明確になった。

最初の簡単な実験においても、1～100 までで分けて A の要素をその余りで分類していたのだが、dpを考えているときにはそんな考えが消え失せていた。解くために必要なものはすべて揃っているのでおしいように感じるが、遠い。まだ武器になってない。


# ☆ Jumping Takahashi 2   diff 1203 

降参

備考

➀　思考

最大のジャンプ台をもつ頂点を始点としたときの 最小の辺をなす頂点を求め、その頂点を次の始点にこれを繰り返して全頂点を探索する処理によって、最大の辺を求めることができると考えた。

➁ 解法1

このような反例で、最大のジャンプ台がある頂点を始点にする方針は間違い

![image](https://user-images.githubusercontent.com/109026838/209312488-7723e07a-670d-4de1-bb1f-338b1bcd6518.png)

その頂点を始点とした場合の最大の辺を求めること自体はできているので、始点も全探索すれば O(N^3 : 始点　× 全頂点探索 N^2) で十分高速にこの問題を解くことが可能である。


③　解法 2

ワーシャルフロイド法によって全点間最短距離を求めておけば、始点を固定した場合の最小有向全域木の最大の辺の重みを求めることが可能になる。したがって、始点を全探索してこれらの最小値を求めばよい

④　解法 3

ジャンプ力を二分探索し、mid 以下の辺を張ったグラフが有向全域木になっているか判定することでこの問題を解答できる

有向全域木になっているかどうかは、BFSで全頂点を探索できるか調べたり や　ワーシャルフロイト法で度の頂点にも辺が張られているか調べることで求められるので　計算量は O(N^3 log10^9) 

⑤　補足

https://atcoder.jp/contests/abc257/editorial/4281

この解法は手を付けていない。いつかやる


# グラフ理論　勉強

・全域木

全頂点が連結している木

・強連結成分

始点と終点が一致する連結成分

・DAG 

非巡回有向グラフ。閉路のない有向グラフを指す



# ワーシャルフロイド法 勉強

全点間最短距離を O (N^3) で求めるアルゴリズム。中継点を kとして (i,j) 間距離 dist[i][j] を dist[i][k] + dist[k][j] と比較して更新していく。

また、経路復元のために prev リストを作成して、dist が更新されるたびに、 prev[i][j]= prev[k][j] としていく。= k としない理由は以下。 prev リストの初期値は 行のindex 番号にすることで　ゴールから始点までの経路を求められる

![image](https://user-images.githubusercontent.com/109026838/209309721-1a96a94c-0cbf-4b8f-babc-ba37f0b5ad29.png)


























